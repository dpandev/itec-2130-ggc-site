<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Rocket Game</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="score" class="hidden">Score: 0</div>
        
        <div id="startScreen">
            <h1>ðŸš€ SPEEDY ROCKET ðŸš€</h1>
            <p>Navigate your rocket through space and dodge the incoming asteroids!</p>
            <p class="instructions">
                <strong>Desktop:</strong> Left Mouse = Up | Right Mouse = Down<br>
                <strong>Mobile:</strong> Tap Left Side = Up | Tap Right Side = Down<br>
                Release to return to center
            </p>
            <button id="startButton">START GAME</button>
        </div>
        
        <div id="gameOverScreen" class="hidden">
            <h2>ðŸ’¥ GAME OVER ðŸ’¥</h2>
            <p id="crashMessage">Your rocket crashed into asteroids!</p>
            <div id="finalScore">Score: 0</div>
            <button id="restartButton">RESTART GAME</button>
        </div>
    </div>

    <!-- Footer Links -->
    <div class="footer-links">
        <div class="footer-left">
            <a href="https://validator.w3.org/nu/?doc=https://dpanesiu.domains.ggc.edu/Projects/project4/project4.html" 
               class="validator-button" 
               target="_blank" 
               rel="noopener noreferrer"
               aria-label="Validate HTML">
                Valid HTML
            </a>
            <a href="https://jigsaw.w3.org/css-validator/validator?uri=https://dpanesiu.domains.ggc.edu/Projects/project4/styles.css" 
               class="validator-button" 
               target="_blank" 
               rel="noopener noreferrer"
               aria-label="Validate CSS">
                Valid CSS
            </a>
        </div>
        <div class="footer-right">
            <a href="https://github.com/dpandev/Speedy-Rocket-Game" 
               class="github-button" 
               target="_blank" 
               rel="noopener noreferrer"
               aria-label="View Original Java Game on GitHub">
                <i class="fab fa-github"></i> Original Game
            </a>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('score');
        const finalScoreDisplay = document.getElementById('finalScore');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');

        // Game state
        let gameRunning = false;
        let score = 0;
        let gameTime = 0;
        let leftMouseDown = false;
        let rightMouseDown = false;
        
        // Difficulty settings
        const initialBackgroundSpeed = 2;
        const initialAsteroidSpeed = 2;
        const difficultyIncreaseRate = 0.00015; // Speed multiplier per millisecond

        // Load images
        const images = {
            rocket: new Image(),
            background: new Image(),
            asteroid: new Image(),
            explosion: new Image()
        };

        images.rocket.src = 'assets/rocketship.png';
        images.background.src = 'assets/background.png';
        images.asteroid.src = 'assets/asteroid.png';
        images.explosion.src = 'assets/explosion2d.png';

        // Game objects
        const rocket = {
            x: 150,
            y: canvas.height / 2,
            targetY: canvas.height / 2,
            width: 60,
            height: 40,
            speed: 3,
            entering: true,
            entryX: -100
        };

        const background = {
            x: 0,
            y: 0,
            speed: initialBackgroundSpeed,
            scaledWidth: 0
        };

        const asteroids = [];
        const asteroidSpawnInterval = 2000; // spawn every 2 seconds
        let lastAsteroidSpawn = 0;

        let explosion = null;

        // Initialize game
        function init() {
            score = 0;
            gameTime = 0;
            asteroids.length = 0;
            explosion = null;
            leftMouseDown = false;
            rightMouseDown = false;
            
            rocket.x = 150;
            rocket.y = canvas.height / 2;
            rocket.targetY = canvas.height / 2;
            rocket.entering = true;
            rocket.entryX = -100;
            
            background.x = 0;
            background.y = 0;
            background.speed = initialBackgroundSpeed;
            
            lastAsteroidSpawn = 0;
        }

        // Start game
        function startGame() {
            init();
            gameRunning = true;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            gameLoop();
        }

        // End game
        function endGame() {
            gameRunning = false;
            scoreDisplay.classList.add('hidden');
            finalScoreDisplay.textContent = `Score: ${score}`;
            
            // Show explosion at rocket position
            explosion = {
                x: rocket.x,
                y: rocket.y,
                frame: 0,
                maxFrames: 30
            };
            
            // Show game over screen after explosion animation
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 500);
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            if (!gameRunning || rocket.entering) return;
            
            e.preventDefault();
            if (e.button === 0) { // Left click
                leftMouseDown = true;
                rocket.targetY = canvas.height * 0.25; // Pull up to 25% of screen
            } else if (e.button === 2) { // Right click
                rightMouseDown = true;
                rocket.targetY = canvas.height * 0.75; // Pull down to 75% of screen
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!gameRunning) return;
            
            e.preventDefault();
            if (e.button === 0) {
                leftMouseDown = false;
            } else if (e.button === 2) {
                rightMouseDown = false;
            }
            
            // If both buttons are released, return to center
            if (!leftMouseDown && !rightMouseDown) {
                rocket.targetY = canvas.height / 2;
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch events for mobile
        let activeTouches = new Set();
        
        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning || rocket.entering) return;
            
            e.preventDefault();
            
            // Get all touches
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                
                // Left half of screen = go up, right half = go down
                if (touchX < canvas.width / 2) {
                    leftMouseDown = true;
                    rocket.targetY = canvas.height * 0.25;
                    activeTouches.add('left');
                } else {
                    rightMouseDown = true;
                    rocket.targetY = canvas.height * 0.75;
                    activeTouches.add('right');
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!gameRunning) return;
            
            e.preventDefault();
            
            // Check if any touches remain
            let hasLeftTouch = false;
            let hasRightTouch = false;
            
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                
                if (touchX < canvas.width / 2) {
                    hasLeftTouch = true;
                } else {
                    hasRightTouch = true;
                }
            }
            
            // Update states based on remaining touches
            if (!hasLeftTouch) {
                leftMouseDown = false;
                activeTouches.delete('left');
            }
            if (!hasRightTouch) {
                rightMouseDown = false;
                activeTouches.delete('right');
            }
            
            // If no touches remain, return to center
            if (!leftMouseDown && !rightMouseDown) {
                rocket.targetY = canvas.height / 2;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Update game state
        function update(deltaTime) {
            if (!gameRunning) return;

            gameTime += deltaTime;

            // Update score
            score += Math.floor(deltaTime / 10);
            scoreDisplay.textContent = `Score: ${score}`;
            
            // Progressive difficulty - increase speed over time
            const speedMultiplier = 1 + (gameTime * difficultyIncreaseRate);
            background.speed = initialBackgroundSpeed * speedMultiplier;

            // Rocket entry animation
            if (rocket.entering) {
                rocket.entryX += 4;
                rocket.x = rocket.entryX;
                if (rocket.x >= 150) {
                    rocket.entering = false;
                    rocket.x = 150;
                }
            } else {
                // Smooth rocket movement towards target Y
                const diff = rocket.targetY - rocket.y;
                rocket.y += diff * 0.1; // Smooth interpolation
            }

            // Update background (scrolling from right to left)
            background.x -= background.speed;
            // Reset when one full background width has scrolled
            if (background.scaledWidth > 0 && background.x <= -background.scaledWidth) {
                background.x = 0;
            }

            // Spawn asteroids after 3 seconds (spawn rate increases over time)
            const currentSpawnInterval = Math.max(800, asteroidSpawnInterval - (gameTime * 0.1));
            if (gameTime > 3000 && gameTime - lastAsteroidSpawn > currentSpawnInterval) {
                spawnAsteroid();
                lastAsteroidSpawn = gameTime;
            }

            // Update asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                asteroid.x -= asteroid.speed;
                asteroid.rotation += asteroid.rotationSpeed;

                // Remove off-screen asteroids
                if (asteroid.x + asteroid.width < 0) {
                    asteroids.splice(i, 1);
                    continue;
                }

                // Collision detection (only after rocket entry)
                if (!rocket.entering && checkCollision(rocket, asteroid)) {
                    endGame();
                    return;
                }
            }

            // Update explosion animation
            if (explosion) {
                explosion.frame++;
                if (explosion.frame > explosion.maxFrames) {
                    explosion = null;
                }
            }
        }

        // Spawn asteroid
        function spawnAsteroid() {
            // Progressive difficulty - asteroids get faster over time
            const speedMultiplier = 1 + (gameTime * difficultyIncreaseRate);
            const baseSpeed = initialAsteroidSpeed + Math.random() * 2;
            
            const size = 40 + Math.random() * 40;
            const asteroid = {
                x: canvas.width,
                y: Math.random() * (canvas.height - size),
                width: size,
                height: size,
                speed: baseSpeed * speedMultiplier,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.1
            };
            asteroids.push(asteroid);
        }

        // Collision detection
        function checkCollision(rect1, rect2) {
            // Simple AABB collision with some padding for better gameplay
            const padding = 10;
            return rect1.x + padding < rect2.x + rect2.width - padding &&
                   rect1.x + rect1.width - padding > rect2.x + padding &&
                   rect1.y + padding < rect2.y + rect2.height - padding &&
                   rect1.y + rect1.height - padding > rect2.y + padding;
        }

        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background (scrolling right to left)
            if (images.background.complete) {
                // Calculate scaled dimensions (only once per frame)
                const scale = canvas.height / images.background.height;
                const scaledWidth = images.background.width * scale;
                
                // Store for use in update function
                background.scaledWidth = scaledWidth;
                
                // Calculate how many copies we need to cover the screen
                const numCopies = Math.ceil(canvas.width / scaledWidth) + 1;
                
                // Draw multiple copies for seamless horizontal scrolling
                for (let i = 0; i <= numCopies; i++) {
                    ctx.drawImage(
                        images.background,
                        i * scaledWidth + background.x,
                        0,
                        scaledWidth,
                        canvas.height
                    );
                }
            }

            // Draw asteroids
            asteroids.forEach(asteroid => {
                if (images.asteroid.complete) {
                    ctx.save();
                    ctx.translate(asteroid.x + asteroid.width / 2, asteroid.y + asteroid.height / 2);
                    ctx.rotate(asteroid.rotation);
                    ctx.drawImage(images.asteroid, -asteroid.width / 2, -asteroid.height / 2, asteroid.width, asteroid.height);
                    ctx.restore();
                }
            });

            // Draw rocket
            if (images.rocket.complete && !explosion) {
                ctx.save();
                ctx.drawImage(images.rocket, rocket.x - rocket.width / 2, rocket.y - rocket.height / 2, rocket.width, rocket.height);
                ctx.restore();
            }

            // Draw explosion
            if (explosion && images.explosion.complete) {
                const scale = 1 + (explosion.frame / explosion.maxFrames) * 0.5;
                const alpha = 1 - (explosion.frame / explosion.maxFrames);
                ctx.save();
                ctx.globalAlpha = alpha;
                const explosionSize = 80 * scale;
                ctx.drawImage(images.explosion, explosion.x - explosionSize / 2, explosion.y - explosionSize / 2, explosionSize, explosionSize);
                ctx.restore();
            }
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp = 0) {
            if (!gameRunning && !explosion) return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        // Handle window resize for responsive canvas
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const rect = container.getBoundingClientRect();
            
            // Only update if size has changed
            if (canvas.width !== rect.width || canvas.height !== rect.height) {
                canvas.width = Math.floor(rect.width);
                canvas.height = Math.floor(rect.height);
                
                // Update rocket position to stay centered
                if (!rocket.entering) {
                    rocket.y = canvas.height / 2;
                    rocket.targetY = canvas.height / 2;
                }
                
                // Redraw if not running
                if (!gameRunning) {
                    draw();
                }
            }
        }

        // Initial resize
        resizeCanvas();
        
        // Resize on window resize (debounced)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 100);
        });

        // Initial draw
        draw();
    </script>
</body>
</html>

